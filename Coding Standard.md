1. Структура решения
	1. Решение и проекты
		* Решение и проекты именуются верхним кэмел-кейзом без явных разделителей. т.е. `SlnMethTask1`, `PrjMethTask1a`
	2. Каталоги  
		1. Каталоги (фильтры) внутри поекта именуются верхним кэмел-кейзом без явных резделителей (`FolderMama`).
		2. Физическое дерево каталогов (на жестком диске) повторяет логическое (фильтры VS).
		3. Желательно дробить директории до содержащих один файл `.h`
		4. Если файл `.h` сопровождается `.cpp`, то `.cpp` выделяются в поддиректорию cpp, содержащую только их (его).  
			* Исключением является файл `main.cpp`, находящийся на наивысшем уровне,
			и остальные файлы находятся на более низких уровнях,
			т.е. main.cpp - единственный файл кода в своем каталоге.
		5. Файлы именуются в нижнем регистре с разделителем `_`, т.е. `file_name.h`
				
2. Препроцессор
	1. Защита от повторного включения
		* Используется защита вида `#ifndef`, константа имеет формат `_FILE_NAME_H_`
	2. Макросы препроцессора
		* Желательно избегать использования макросов препроцессора для эмуляции константы, функции, шаблона.
			* Предпочтительнее использовать соответствующие им конструкции языка.
			* Сказанное не касается условной компилляции
	3. Именование
		* Конструкции препроцессора именуются в верхнем регистре с разделителем `_`, т.е. `#define FOO_NONCOMPILE_1`
	4. Минимизация зависимостей
		* Желательно минимизировать зависимости файлов, указывая в них минимальное возможное количество заголовочных файлов.
			* Однако, для заголовочного файла список включений, неявно рассчитывающий на то, что перед фключением файла будут включены какие-либо другие,
			считается категорически некорректным. Этот пункт включает более частные случаи зависимости корректности от порядка подключения.
			Но дублировать заголовки в cpp-файлах крайне нежелательно
	5. Порядок включения
		* Включения упорядочиваются по убыванию стандартности. Таким образом, первым блоком (разделять пустой строкой)
			* будут файлы стандартной библиотеки C, далее C++, далее Boost, далее другие используемые сторонние библиотеки, и последним блоком файлы текущего проекта.	

3. Именование
	1. Регистр
		* Имена пишутся без явных разделителей в нижнем регистре. Для имен структур, классов, функций, методов и констант используется верхний кэмел-кейз,
			* Для данных используется нижний кэмел-кейз. Это касается всех случаев, включая объявления переменных и параметров.
			* Для функций, передаваемых в качестве параметра, кейз определяется из оттенка смысла: для переменной типа функция, принимающей различные значения в данном контексте, используется правило для переменных, а для логически константных функций - для функций. Так, скорее всего, указатель на функцию в параметрах функции будет именоваться по правилам для функций.
			* Аналогично, класс-параметр шаблона будет именоваться по правилам класса.
	2. Лексика
		* В именах используется ТОЛЬКО английская лексика. Транслитерация недопустима.
		* Не рекомендуется использования товарных марок, а так же слов и выражений в переносном смысле или привязанных к конкретной субкультуре.
	3. Грамматика
		* Имена переменных и функций должны быть грамматически верными конструкциями английского языка (за исключением, очевидно, конструктора/деструктора).
		* Функция обязательно начинается с инфинитива глагола (`DoSomething()`, `GetFoo()`, `Iterate()`), переменные булевой алгебры - с элементарного предиката
			(`isBar`, `hasSomething`, `isDoingFoo`).
	4. Осмысленность
		* Названия переменных должны быть максимаьно полными, желательно, понятными, даже будучи вырванными из контекста использования.
			* Отступление возможно в том случае, если от соблюдения значительно страдает читабельность кода.
			Использование коротких переменных оправданно для итераторов, индексов, переменных, сопоставляемых с математическими формулами.
	5. Сокращения
		* Использование каких-либо сокращений не рекомендуется. Прежде чем использовать сокращение, следует задуматься, является ли оно общепринятым и соответствует ли пункту 3.3.
	6. Модификатор доступа
		* Непубличные методы/константы класса и статические функции/константы модуля предвараяются нижним подчеркиванием (`_InitSomethingUserDontKnow()`, `_PiInThisModule = 3`..
			* Непубличные поля класса пишутся обычным образом (публичные поля класса нежелательны впринцпе, доступ к ним следует организовать функциями вида `SetBar`/`GetBar`).
	7. Пространства имен
		* Все идентификаторы должны принадлежать какому-либо разумно ограниченному пространству имен. По меньшей мере одно пространство имен является специфичным для решения.
			* Имя пространства имен должно быть коротким, полностью в нижнем регистре, может являться необщепринятым сокращением.
	8. Венгерская нотация
		* Начинать имя переменной с идентификатора класса (в смысле множеств), к которому она принадлежит, приветсвтуется. Однако венгерская нотация в чистом виде запрещена.
			* Общность класса определяется из соображений целесообразности в данном контексте.
				
4. Пробелы, табуляция, скобки в определениях и объявлениях
	1. Фигурные скобки и переносы в объявленииях
		* Следует выделять в отдельнуе строки:
			* любую конструкцию вида `template<...>` в определениях и объявлениях;
			* имя определяемого пространства имен, функции или класса;
			* фигурную скобку в начале(и в конце) определения пространства имен, функции или класса.
	2. Части имени функции
		* Тип возвращаемого зщначения, а так же пространста имен, включая пространство класса для метода, являются частью имени и находятся в строке с именем.
	3. Размер табуляции
		* Символ табуляции приравнивается к четырем пробелам и заменяется на них. Замечание: код не будет слишком широким, будет объяснено позднее.
	4. Многострочные списки параметров
		* Перенос строки в многострочках списках параметров осуществляется в первый раз после открывающей скобки.
		* Строки параметров начинаются под именем функции с одиночной табуляцией.
	5. Модификаторы доступа
		* Модификаторы доступа (`public:`, `private:`, `protected:`) пишутся под фигурной скобкой, открывшей определение.
	6. Замечание о пропускаемых именах параметров функций
		* В объявленииях ОБЯЗАТЕЛЬНО указывать имена параметров функций.
		* Пустой список параметров `void` опускается как в объявлении, так и в определнии.
				
		
### Примеры:

```cpp
namespace foo {
	class Сatalog
	{
	public:
		explicit Catalog() {}
	}
}

template<typename T>
void foo::Dummy::TemplateMethod(
	T* target,
	std::basic_string<T> const& source)
{}
```

5. Форматирование блоков
	1. Фигурные скобки
			Внутри блока фигурные скобки открываются на той же строке, что и конструкция, к которой они относятся, и закрываются на пустой строке под конструкцией.
				Конструкции `if`, `else`, `while`, `for` и им подобные **всегда** порождают блок фигурных скобок. Недопустимо использование несоставных выражений (не обособленных скобками).
				Использование блоков фигурных скобок между case не рекомендуется (скорее всего, такой код разумно выделить в функцию), но допустимо.
	2. Табуляция
			Табуляция при вложении блоков составляет 4 пробела. Метки (включая case <>:) пишутся на одном уровне с открывающей скобкой блока.
	3. Многострочные выражения.
			В выражениях допустимы вольные переносы по эстетическим соображениям. Обязательно соблюдение вложенности операндов (при повышении вложенности добавляется одна табуляция).
				Первый перенос многострочного выражения так же порождает смещение табуляции.
	4. Переносы в `if`, `else if`, `else` конструкции
			Слово else пишется на той же строке, что и пердыдущая закрывающая скобка. На этой же строке пишется `if ()`, если требуется, и открывающая скобка порожденного блока.
	5. Внутриблочная условная компилляция
			Локальные блоки условной компилляции подчиняются тем же правилам, что и обычная `if`-конструкция (в то время как внешняя условная компилляция начинается всегда с начала строки).
	6. Пустые строки
			Обязательно обособлять логически связные отрывки кода пустыми строками (желательно, разумеется, добавлять к этому однострочный комментарий, но это не всегда оправданно).
				Это позволит быстрее отлавливать необходимость введения новых функций, а так же значительно способствует лучшему пониманию кода при чтении.
	7. Пробелы применительно к операциям
			Инфиксные операции обособляются пробелами. Префиксные и постфиксые операции тяготеют к их аргументам. Части триплексной операции обособляются пробелами.
				Операции `<<` и `>>` являются инфиксными. Операции `.` и `->` пробелами не обособляются.


	
### Другие указания

* конст
* инлайн
* нестед иф и сокращение вложенности
* функции
* статические функции модуля вместо статических приватов класса
* безопасность относительно исключений
* соответствие порядка полей класса и списка инициализации конструктора.
* пространства имен
* варнинги
* языки
* С++ 11 нуллптр
* списки инициализации (порядок и оформление)
* промежуточные переменные
* ипользование конструкторов
* префиксный инеремент